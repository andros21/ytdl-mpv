#!/usr/bin/env bash

# Default envs
SOCKET=/tmp/mpvsocket

# Ensure dependencies
_checkDep() {
   type mpv > /dev/null 2>&1 || {
      printf '%s\n' "[Error] Cannot find mpv on your \$PATH" >&2
      exit 1
   }

   type nc > /dev/null 2>&1 && SOCKCMD="nc -U -N $SOCKET"
   type socat > /dev/null 2>&1 && SOCKCMD="socat - $SOCKET"

   [ "$SOCKCMD" ] || {
      printf '%s\n' "[Error] Cannot find socat or nc on your \$PATH. Install before continue" >&2
   exit 1
   }
}

# Check if sock is idle, otherwise exit
_checkSock() {
   if [ ! -S $SOCKET  ]; then
      printf '[Error] Cannot find mpv socket file\n' >&2
      exit 1
   fi
   printf '{ "command:" [ "get_version" ] }' | $SOCKCMD &> /dev/null
   local return_code=$?
   if [ ! "$return_code" -eq 0 ]; then
      printf '[Error] Cannot connect to mpv socket, connection refused\n' >&2
      exit 1
   fi
}

# Usage (help) message
_usage() {
    cat >&2 << EOF
usage: $(basename $0) [-h] [--sock] SOCKET action

MPVCTL - mpv cli ipc-json frontend

positional arguments:
  add              add items to playlist
  check            check socket status
  clear            playlist clear
  load             load a playlist from given path
  loop             loop/unloop currently playing playlist
  loop-status      get loop status currently playling playlist
  next             play next item in playlist
  playlist         print id | title of tracks
  prev             play previous item in playlist
  remove           remove item number from playlist
  save             save current playlist to given path
  stop             always stop playback
  toggle           toggle playback
  track            jump to playlist item number

optional arguments:
  -s | --socket    set socket location [default: $SOCKET]
  -h | --help      print this help
EOF
    [ -z "$1" ] && exit || exit "$1"
}

# Check sock status, only for information
_getSock() {
   if [ ! -S $SOCKET  ]; then
      printf 'disabled\n'
      exit 0
   fi
   printf '{ "command:" [ "get_version" ] }' | $SOCKCMD &> /dev/null
   local return_code=$?
   if [ ! "$return_code" -eq 0 ]; then
      printf 'disabled\n'
      exit 0
   fi
   printf 'enabled\n'
   exit 0
}

# Get current playlist formatted and sorted
_getPlaylist() {
   # track numbers
   local trnum=$(_getProperty 'get_property_string' 'playlist-count')
   # current track number
   local trcur=$(_getProperty 'get_property_string' 'playlist-pos')
   # if a playlist cache file is passed, use to search name for yt media
   if [ ! -z $1 ] && [ -f $1 ]; then local gcp=$(cat $1 | gzip -dq | base64 -d); fi

   local count=0
   while [ $count -lt $trnum ]; do
      # current track mark
      local trcurmark=' '
      # track name
      local trname=$(_getProperty 'get_property_string' "playlist/$count/filename")
      if [ $count -eq $trcur ]; then local trcurmark='*'; fi
      # check if local or yt media
      if [[ $trname =~ ^ytdl://(.*)$ ]]; then
         # track id
         local trid=${trname:7}
         # if a global playlist cache file, search yt media using it
         if [ ! -z "$gcp" ]; then
            # grep from file otherwise search it
            local trtitle=$(printf '%s\n' "$gcp" | grep -w "$trid" | awk -F'|' '{print $2}')
            local trtitle=${trtitle:1}
            if [ -z "$trtitle" ]; then
               local trtitle=$(youtube-dl --get-filename "$trid" -o "%(title)s" 2> /dev/null)
            fi
         else
            # searching track title, using ytdl
            local trtitle=$(youtube-dl --get-filename "$trid" -o "%(title)s" 2> /dev/null)
         fi
         if [ -z "$trtitle" ]; then
            printf '[Error] youtube-dl title search fail\n' >&2
            local trtitle="NULL"
         fi
      else
         # other media file type, not yt url
         local trtitle=$trname
      fi

      zerocount=$(printf '%s\n' "$count" | sed 's/\<[0-9]\>/0&/')
      printf '%s)%s %s | %s\n' "$zerocount" "$trcurmark" "$trid" "$trtitle"
      count=$(($count + 1))
   done
}

# Save current playlist to given file
_savePlaylist() {
   if [ -z $1 ]; then
      printf '[Error] None path given\n' >&2
      exit 1
   fi
   if [ ! -d $(dirname $1) ]; then
      printf '[Error] Invalid path given\n' >&2
      exit 1
   fi
   # track numbers
   local trnum=$(_getProperty 'get_property_string' 'playlist-count')

   local count=0
   while [ $count -lt $trnum ]; do
      # track name
      local trname=$(_getProperty 'get_property_string' "playlist/$count/filename")
      printf '%s\n' "$trname"
      count=$(($count + 1))
   done > $1
}

# Load playlist from given file
_loadPlaylist() {
   if [ -z $1 ]; then
      printf '[Error] None path given\n' >&2
      exit 1
   fi
   if [ ! -f $1 ]; then
      printf '[Error] Invalid path given\n' >&2
      exit 1
   fi

   for track in $(cat $1); do
      _setProperty 'loadfile' "$track" 'append-play'
   done
}

# Get loop status
_getLoop() {
   #loop state
   local lstate=$(_getProperty 'get_property_string' 'loop-playlist' \
      | sed "s/inf/on/" | sed "s/no/off/")

   printf '%s\n' "$lstate"
}

# Toggle loop playlist
_toggleLoop() {
   if [ "$(_getLoop)" == "off" ]; then
      _setProperty 'set_property' 'loop-playlist' 'inf';
   else
      _setProperty 'set_property' 'loop-playlist' 'no';
   fi
}

# Get method to read from socket
_getPropertyDebug() {
   _checkSock
    local tosend='{ "command": ['
    for arg in "$@"; do
        tosend="$tosend \"$arg\","
    done
    tosend=${tosend%?}' ] }'
    local property=$(printf '%s\n' "$tosend" | $SOCKCMD 2> /dev/null)
    printf '%s\n' "$property"
}
# Get method to read from socket
_getProperty() {
   _checkSock
    local tosend='{ "command": ['
    for arg in "$@"; do
        tosend="$tosend \"$arg\","
    done
    tosend=${tosend%?}' ] }'
    local property=$(printf '%s\n' "$tosend" | $SOCKCMD 2> /dev/null \
       | cut -d'"' -f 4 | rev | cut -d'.' -f 2- | rev)
    printf '%s\n' "$property"
}

# Set method to write from socket
_setProperty() {
   _checkSock
    local tosend='{ "command": ['
    for arg in "$@"; do
        tosend="$tosend \"$arg\","
    done
    tosend=${tosend%?}' ] }'
    printf '%s\n' "$tosend" | $SOCKCMD &> /dev/null
}

case $1 in
   -s | --socket)  if [ ! -z $2 ]; then SOCKET=$2; shift; fi; shift;;
   -h | --help)    _usage;;
esac

if [ ! -z $1 ]; then _checkDep; fi;

case "$1" in
   add)            shift && for track in "$@"; do _setProperty 'loadfile' "$track" 'append-play'; done;;
   check)          _getSock;;
   clear)          _setProperty 'playlist_clear';;
   load)           _loadPlaylist $2;;
   loop)           _toggleLoop;;
   loop-status)    _getLoop;;
   next)           _setProperty 'playlist_next';;
   playlist)       _getPlaylist $2;;
   prev)           _setProperty 'playlist_prev';;
   rm)             _setProperty 'playlist_remove' $2;;
   save)           _savePlaylist $2;;
   stop)           _setProperty 'quit';;
   toggle)         _setProperty 'cycle' 'pause';;
   track)          _setProperty 'set_property' 'playlist-pos' $2;;
   *)              _usage;;
esac
